##--## Minimum Optifine Version ##--------------------------------------------##

version.1.13.2=E5_pre2

##--## Shader Options Menu ##-------------------------------------------------##

sliders = HAND_FOV sunPathRotation \
\
AO_RADIUS HBAO_DIRECTIONS HBAO_ANGLE_SAMPLES \
\
ARTIFICIAL_LIGHT_LUMINANCE ARTIFICIAL_LIGHT_SIZE ARTIFICIAL_LIGHT_TEMPERATURE \
\
CAMERA_EXPOSURE_BIAS CAMERA_FOCUS_DISTANCE CAMERA_FSTOP CAMERA_ISO CAMERA_SHUTTER_SPEED DOF_SAMPLES MOTION_BLUR_SAMPLES \
CAMERA_IRIS_BLADE_COUNT CAMERA_IRIS_BLADE_ROTATION CAMERA_IRIS_BLADE_ROUNDING \
\
PARALLAX_DEPTH PARALLAX_QUALITY WATER_PARALLAX_DEPTH_MULTIPLIER WATER_PARALLAX_STEPS \
WATER_WAVES_COUNT WATER_WAVES_SPEED WATER_WAVES_WAVELENGTH WATER_WAVES_WAVE_HEIGHT WATER_WAVES_WAVELENGTH_GAIN WATER_WAVES_WAVE_HEIGHT_GAIN \
\
GAMMA_LUMINANCE GAMMA_CHROMINANCE CONE_OVERLAP_SIMULATION \
COLORMATRIX_R_TO_R COLORMATRIX_G_TO_R COLORMATRIX_B_TO_R COLORMATRIX_R_TO_G COLORMATRIX_G_TO_G COLORMATRIX_B_TO_G COLORMATRIX_R_TO_B COLORMATRIX_G_TO_B COLORMATRIX_B_TO_B LIFT_R LIFT_G LIFT_B \
TONEMAP_TOE_STRENGTH TONEMAP_TOE_LENGTH TONEMAP_LINEAR_LENGTH TONEMAP_SHOULDER_CURVE \
TAA_MOTION_REJECTION \
\
RSM_BRIGHTNESS RSM_SAMPLES RSM_RADIUS \
\
shadowMapResolution SHADOW_DISTANCE_EFFECTIVE shadowDistance \
\
SHADOW_FILTER_SAMPLES SHADOW_SEARCH_SAMPLES \
CAUSTICS_SAMPLES CAUSTICS_FOCUS CAUSTICS_POWER \
\
FOG_AIR_DENSITY \
CLOUDS2D_SELFSHADOW_QUALITY CLOUDS2D_COVERAGE \
CLOUDS3D_STEPS CLOUDS3D_STATIC_COVERAGE CLOUDS3D_SPEED CLOUDS3D_ALTITUDE CLOUDS3D_THICKNESS_MULT CLOUDS3D_SCALE \
\
SSR_RAY_COUNT SSR_RAY_REFINEMENTS SSR_RAY_STEPS SSR_TAIL_CLAMP \
\
WATER_SCATTERING_R WATER_SCATTERING_G WATER_SCATTERING_B WATER_TRANSMISSION_R WATER_TRANSMISSION_G WATER_TRANSMISSION_B

screen = [ambientOcclusion] [artificialLight] [camera] [material] [postProcess] [rsm] [shadowMaps] [shadows] [sky_atmosphere] [ssr] [water] <empty> <empty> <empty> [miscellaneous]
screen.miscellaneous = * [debug]
screen.debug = DEBUG_HISTOGRAM DEBUG_TONEMAP

screen.ambientOcclusion = AO_METHOD AO_RADIUS <empty> <empty> HBAO_DIRECTIONS HBAO_ANGLE_SAMPLES
screen.artificialLight = ARTIFICIAL_LIGHT_LUMINANCE ARTIFICIAL_LIGHT_SIZE ARTIFICIAL_LIGHT_TEMPERATURE <empty> <empty> <empty> ARTIFICIAL_LIGHT_DIRECTIONAL ARTIFICIAL_LIGHT_USE_AO <empty> <empty> EMISSIVE_TEMP_FIX
screen.camera = CAMERA_AUTOEXPOSURE CAMERA_EXPOSURE_BIAS CAMERA_AUTOFOCUS CAMERA_FOCUS_DISTANCE <empty> <empty> CAMERA_FSTOP CAMERA_ISO CAMERA_SHUTTER_SPEED [iris] <empty> <empty> DOF DOF_SAMPLES MOTION_BLUR MOTION_BLUR_SAMPLES
screen.material = RESOURCE_FORMAT [parallax] <empty> <empty> SMOOTH_ALBEDO SMOOTH_NORMALS SMOOTH_SPECULAR
screen.postProcess = GAMMA_LUMINANCE GAMMA_CHROMINANCE [colorMatrix] [tonemapping] LUT <empty> <empty> <empty> [taa] BLOOM LOWLIGHT_DESATURATION LOWLIGHT_NOISE CONE_OVERLAP_SIMULATION
screen.rsm = RSM RSM_BRIGHTNESS RSM_SAMPLES RSM_RADIUS <empty> <empty> RSM_LEAK_FIX
screen.shadowMaps = shadowMapResolution SHADOW_DISTANCE_EFFECTIVE SHADOW_INFINITE_RENDER_DISTANCE shadowDistance <empty> <empty> SHADOW_BACKFACE_CULLING BEACON_BEAM_SHADOWS
screen.shadows = SHADOW_FILTER SHADOW_COLORED SHADOW_FILTER_SAMPLES SHADOW_SEARCH_SAMPLES <empty> <empty> [sscs]
screen.sky_atmosphere = SKY_RENDER_LOD SKY_IMAGE_LOD [clouds2D] [clouds3D] <empty> <empty> VL_AIR FOG_AIR_DENSITY DISTANT_VL
screen.ssr = SSR_RAY_COUNT SSR_TAIL_CLAMP SSR_RAY_STEPS SSR_RAY_REFINEMENTS <empty> <empty> RAYTRACER_HQ
screen.water = USE_WATER_TEXTURE [proceduralWaves] [waterFog] [caustics]

screen.iris = CAMERA_IRIS_BLADE_COUNT CAMERA_IRIS_BLADE_ROTATION CAMERA_IRIS_BLADE_ROUNDING
screen.parallax = PARALLAX PARALLAX_SHADOWS SMOOTH_PARALLAX SMART_PARALLAX PARALLAX_DEPTH PARALLAX_QUALITY
screen.colorMatrix = COLORMATRIX_R_TO_R COLORMATRIX_G_TO_R COLORMATRIX_B_TO_R COLORMATRIX_R_TO_G COLORMATRIX_G_TO_G COLORMATRIX_B_TO_G COLORMATRIX_R_TO_B COLORMATRIX_G_TO_B COLORMATRIX_B_TO_B <empty> <empty> <empty> LIFT_R LIFT_G LIFT_B
screen.colorMatrix.columns = 3
screen.tonemapping = TONEMAP_TOE_STRENGTH TONEMAP_TOE_LENGTH TONEMAP_LINEAR_LENGTH TONEMAP_SHOULDER_CURVE
screen.taa = TAA TAA_CLIP TAA_YCoCg TAA_MOTION_REJECTION
screen.sscs = SSCS SSCS_MODE SSCS_SAMPLES SSCS_STRIDE
screen.clouds2D = CLOUDS2D CLOUDS2D_SELFSHADOW_QUALITY <empty> <empty> CLOUDS2D_COVERAGE CLOUDS2D_USE_WORLD_TIME
screen.clouds3D = CLOUDS3D CLOUDS3D_STEPS CLOUDS3D_SIMPLE_SKYLIGHT_SHADING <empty> <empty> <empty> CLOUDS3D_DYNAMIC_COVERAGE CLOUDS3D_STATIC_COVERAGE CLOUDS3D_USE_WORLD_TIME CLOUDS3D_SPEED <empty> <empty> CLOUDS3D_ALTITUDE CLOUDS3D_THICKNESS_MULT CLOUDS3D_SCALE
screen.proceduralWaves = WATER_WAVES_COUNT WATER_WAVES_SPEED WATER_WAVES_WAVELENGTH WATER_WAVES_WAVE_HEIGHT WATER_WAVES_WAVELENGTH_GAIN WATER_WAVES_WAVE_HEIGHT_GAIN <empty> <empty> WATER_PARALLAX WATER_PARALLAX_DEPTH_MULTIPLIER WATER_PARALLAX_STEPS
screen.waterFog = VL_WATER VL_WATER_CAUSTICS UNDERWATER_ADAPTATION <empty> <empty> <empty> WATER_SCATTERING_R WATER_TRANSMISSION_R WATER_SCATTERING_G WATER_TRANSMISSION_G WATER_SCATTERING_B WATER_TRANSMISSION_B
screen.caustics = CAUSTICS CAUSTICS_DITHERED <empty> <empty> CAUSTICS_SAMPLES CAUSTICS_FOCUS CAUSTICS_POWER CAUSTICS_DISPERSION

##--## Custom Textures #------------------------------------------------------##

# Lookup table
texture.composite.depthtex2 = image/lut.png

# Atmosphere LUTs
texture.deferred.colortex5 = image/scatteringLut.png

texture.gbuffers.gaux4 = image/transmittanceLut.png
texture.deferred.depthtex0 = image/transmittanceLut.png
texture.composite.colortex7 = image/transmittanceLut.png

# Custom noise texture for fast 3D noise
texture.noise = image/noise.png

##--## Misc Renderer Configuration ##-----------------------------------------##

clouds      = off
oldLighting = false
separateAo  = true
rain.depth  = true

##--## Program Toggles ##-----------------------------------------------------##

program.world0/deferred1.enabled = AO_METHOD != AO_VERTEX || RSM

program.world0/composite3.enabled = DOF != DOF_OFF
program.world0/composite4.enabled = DOF != DOF_OFF
program.world0/composite5.enabled = DOF != DOF_OFF || MOTION_BLUR
program.world0/composite6.enabled = BLOOM
program.world0/composite7.enabled = BLOOM

##--## Alpha Test #-----------------------------------------------------------##

# skybasic is always simply discarded
alphaTest.gbuffers_skybasic = off
# skytextured is probably also always going to simply be discarded
alphaTest.gbuffers_skytextured = off

# Alpha test needs to be disabled
alphaTest.gbuffers_textured = off
alphaTest.gbuffers_terrain  = off
alphaTest.gbuffers_block    = off
alphaTest.gbuffers_entities = off
alphaTest.gbuffers_hand     = off
alphaTest.gbuffers_weather  = off
alphaTest.shadow            = off

# Alpha test is done in the shader itself to allow skipping most of the operations
alphaTest.gbuffers_water      = off
alphaTest.gbuffers_hand_water = off

##--## Blend Functions ##-----------------------------------------------------##

blend.gbuffers_textured   = off
blend.gbuffers_terrain    = off
blend.gbuffers_block      = off
blend.gbuffers_entities   = off
blend.gbuffers_hand       = off
blend.gbuffers_water      = ONE ONE_MINUS_SRC_ALPHA ONE ONE_MINUS_SRC_ALPHA
blend.gbuffers_hand_water = ONE ONE_MINUS_SRC_ALPHA ONE ONE_MINUS_SRC_ALPHA

# temp disabled until it's rendered after deferred
blend.gbuffers_weather    = off

##--## Render Scale & Offset ##-----------------------------------------------##

##--## Buffer Flipping ##-----------------------------------------------------##

flip.deferred2.colortex3  = true
flip.composite1.colortex3 = true
flip.composite8.colortex3 = true

flip.composite.colortex6=true

##--## Custom Uniforms ##-----------------------------------------------------##

uniform.vec2.viewResolution = vec2(viewWidth, viewHeight)
uniform.vec2.viewPixelSize = vec2(1.0 / viewWidth, 1.0 / viewHeight)

#  1 ( 1/ 2, 1/ 3), 0.10000 0.100
#  2 ( 1/ 4, 2/ 3), 0.01000 0.200
#  3 ( 3/ 4, 1/ 9), 0.11000 0.010
#  4 ( 1/ 8, 4/ 9), 0.00100 0.110
#  5 ( 5/ 8, 7/ 9), 0.10100 0.210
#  6 ( 3/ 8, 2/ 9), 0.01100 0.020
#  7 ( 7/ 8, 5/ 9), 0.11100 0.120
#  8 ( 1/16, 8/ 9), 0.00010 0.220
#  9 ( 9/16, 1/27), 0.10010 0.001
# 10 ( 5/16,10/27), 0.01010 0.101
# 11 (13/16,19/27), 0.11010 0.201
# 12 ( 3/16, 4/27), 0.00110 0.011
# 13 (11/16,13/27), 0.10110 0.111
# 14 ( 7/16,22/27), 0.01110 0.211
# 15 (15/16, 7/27), 0.11110 0.021
# 16 ( 1/32,16/27), 0.00001 0.121
variable.int.frameMod16 = frameCounter % 16
uniform.vec2.taaOffset = vec2((if( \
	frameMod16 ==  0,  1.0 /  2.0, frameMod16 ==  1,  1.0 /  4.0, \
	frameMod16 ==  2,  3.0 /  4.0, frameMod16 ==  3,  1.0 /  8.0, \
	frameMod16 ==  4,  5.0 /  8.0, frameMod16 ==  5,  3.0 /  8.0, \
	frameMod16 ==  6,  7.0 /  8.0, frameMod16 ==  7,  1.0 / 16.0, \
	frameMod16 ==  8,  9.0 / 16.0, frameMod16 ==  9,  5.0 / 16.0, \
	frameMod16 == 10, 13.0 / 16.0, frameMod16 == 11,  3.0 / 16.0, \
	frameMod16 == 12, 11.0 / 16.0, frameMod16 == 13,  7.0 / 16.0, \
	frameMod16 == 14, 15.0 / 16.0, frameMod16 == 15,  1.0 / 32.0, \
	0.0) * 2.0 - 1.0 \
) / viewWidth, \
(if( \
	frameMod16 ==  0,  1.0 /  3.0, frameMod16 ==  1,  2.0 /  3.0, \
	frameMod16 ==  2,  1.0 /  9.0, frameMod16 ==  3,  4.0 /  9.0, \
	frameMod16 ==  4,  7.0 /  9.0, frameMod16 ==  5,  2.0 /  9.0, \
	frameMod16 ==  6,  5.0 /  9.0, frameMod16 ==  7,  8.0 /  9.0, \
	frameMod16 ==  8,  1.0 / 27.0, frameMod16 ==  9, 10.0 / 27.0, \
	frameMod16 == 10, 19.0 / 27.0, frameMod16 == 11,  4.0 / 27.0, \
	frameMod16 == 12, 13.0 / 27.0, frameMod16 == 13, 22.0 / 27.0, \
	frameMod16 == 14,  7.0 / 27.0, frameMod16 == 15, 16.0 / 27.0, \
	0.0) * 2.0 - 1.0 \
) / viewHeight)

variable.float.sunVectorNorm = 1.0 / sqrt((sunPosition.x * sunPosition.x) + (sunPosition.y * sunPosition.y) + (sunPosition.z * sunPosition.z))
uniform.vec3.sunVectorView = vec3(sunPosition.x * sunVectorNorm, sunPosition.y * sunVectorNorm, sunPosition.z * sunVectorNorm)
variable.float.sunVectorX = gbufferModelViewInverse.0.0 * sunPosition.x + gbufferModelViewInverse.1.0 * sunPosition.y + gbufferModelViewInverse.2.0 * sunPosition.z
variable.float.sunVectorY = gbufferModelViewInverse.0.1 * sunPosition.x + gbufferModelViewInverse.1.1 * sunPosition.y + gbufferModelViewInverse.2.1 * sunPosition.z
variable.float.sunVectorZ = gbufferModelViewInverse.0.2 * sunPosition.x + gbufferModelViewInverse.1.2 * sunPosition.y + gbufferModelViewInverse.2.2 * sunPosition.z
uniform.vec3.sunVector = vec3(sunVectorX * sunVectorNorm, sunVectorY * sunVectorNorm, sunVectorZ * sunVectorNorm)

variable.float.moonVectorNorm = 1.0 / sqrt((moonPosition.x * moonPosition.x) + (moonPosition.y * moonPosition.y) + (moonPosition.z * moonPosition.z))
uniform.vec3.moonVectorView = vec3(moonPosition.x * moonVectorNorm, moonPosition.y * moonVectorNorm, moonPosition.z * moonVectorNorm)
variable.float.moonVectorX = gbufferModelViewInverse.0.0 * moonPosition.x + gbufferModelViewInverse.1.0 * moonPosition.y + gbufferModelViewInverse.2.0 * moonPosition.z
variable.float.moonVectorY = gbufferModelViewInverse.0.1 * moonPosition.x + gbufferModelViewInverse.1.1 * moonPosition.y + gbufferModelViewInverse.2.1 * moonPosition.z
variable.float.moonVectorZ = gbufferModelViewInverse.0.2 * moonPosition.x + gbufferModelViewInverse.1.2 * moonPosition.y + gbufferModelViewInverse.2.2 * moonPosition.z
uniform.vec3.moonVector = vec3(moonVectorX * moonVectorNorm, moonVectorY * moonVectorNorm, moonVectorZ * moonVectorNorm)

variable.float.shadowLightVectorNorm = 1.0 / sqrt((shadowLightPosition.x * shadowLightPosition.x) + (shadowLightPosition.y * shadowLightPosition.y) + (shadowLightPosition.z * shadowLightPosition.z))
uniform.vec3.shadowLightVectorView = vec3(shadowLightPosition.x * moonVectorNorm, shadowLightPosition.y * moonVectorNorm, shadowLightPosition.z * moonVectorNorm)
variable.float.shadowLightVectorX = gbufferModelViewInverse.0.0 * shadowLightPosition.x + gbufferModelViewInverse.1.0 * shadowLightPosition.y + gbufferModelViewInverse.2.0 * shadowLightPosition.z
variable.float.shadowLightVectorY = gbufferModelViewInverse.0.1 * shadowLightPosition.x + gbufferModelViewInverse.1.1 * shadowLightPosition.y + gbufferModelViewInverse.2.1 * shadowLightPosition.z
variable.float.shadowLightVectorZ = gbufferModelViewInverse.0.2 * shadowLightPosition.x + gbufferModelViewInverse.1.2 * shadowLightPosition.y + gbufferModelViewInverse.2.2 * shadowLightPosition.z
uniform.vec3.shadowLightVector = vec3(shadowLightVectorX * shadowLightVectorNorm, shadowLightVectorY * shadowLightVectorNorm, shadowLightVectorZ * shadowLightVectorNorm)
